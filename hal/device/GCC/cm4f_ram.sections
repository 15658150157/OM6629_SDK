/* ----------------------------------------------------------------------------
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 * -------------------------------------------------------------------------- */

/**
 * @defgroup DOC DOC
 * @ingroup  DOCUMENT
 * @brief    GNU Linker Script for Cortex-M based device
 * @details  GNU Linker Script for Cortex-M based device
 *
 * @version
 * Version 1.0
 *  - Initial release
 *
 * @{
 */


/* Define the entry point of the output file. */
ENTRY(Reset_Handler)

SECTIONS
{
    .vectors :
    {
        . = ALIGN(512);
        KEEP(*(.vectors))
    } > ROM

    /* RAM */
    .ram_code :
    {
        . = ALIGN(32);
        __ram_code_start__ = .;
        *(.ram_code)
        . = ALIGN(4);
        *(.ram_rodata)
        . = ALIGN(32);
        __ram_code_end__ = .;
    } > ROM

    .text :
    {
        __code_start__ = .;
        *(.text*)

        KEEP(*(.init))
        KEEP(*(.fini))

        /* .ctors */
        *crtbegin.o(.ctors)
        *crtbegin?.o(.ctors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)

        /* .dtors */
        *crtbegin.o(.dtors)
        *crtbegin?.o(.dtors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        *(.rodata*)

        KEEP(*(.eh_frame*))
        . = ALIGN(32);
        __code_end__ = .;
    } > ROM

    .ARM.extab :
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > ROM

    __exidx_start = .;
    .ARM.exidx :
    {
        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    } > ROM
    __exidx_end = .;

    .copy.table :
    {
        . = ALIGN(4);
        __copy_table_start__ = .;
        LONG (LOADADDR(.ram_data))
        LONG (__ram_data_start__)
        LONG ((__ram_data_end__ - __ram_data_start__ + 3) >> 2)
        __copy_table_end__ = .;
    } > ROM

    .zero.table :
    {
        . = ALIGN(4);
        __zero_table_start__ = .;
        /* ram bss */
        LONG (__ram_bss_start__)
        LONG ((__ram_bss_end__ - __ram_bss_start__ + 3) >> 2)
        /* ram ble em */
        LONG (__ram_ble_em_start__)
        LONG ((__ram_ble_em_end__ - __ram_ble_em_start__ + 3) >> 2)
        __zero_table_end__ = .;
    } > ROM

    /**
    * Location counter can end up 2byte aligned with narrow Thumb code but
    * __etext is assumed by startup code to be the LMA of a section in RAM
    * which must be 4byte aligned
    */
    __etext = ALIGN (4);

    .ram_non_init (NOLOAD):   /* reserved space for ram_code, NOT added any section */
    {
        . = . + LOADADDR(.zero.table) + SIZEOF(.zero.table) - LOADADDR(.vectors);
        *(.ram_data_non_init)
    } > RAM

    .ram_ble_em (NOLOAD):
    {
        . = ALIGN(4);
        __ram_ble_em_start__ = .;
        *(.ram_ble_em)
        . = ALIGN(4);
        __ram_ble_em_end__ = .;
    } > RAM

    .ram_data :
    {
        __ram_data_start__ = .;
        *(vtable)
        *(.data)
        *(.data.*)

        . = ALIGN(4);
        /* preinit data */
        PROVIDE_HIDDEN (__preinit_array_start = .);
        KEEP(*(.preinit_array))
        PROVIDE_HIDDEN (__preinit_array_end = .);

        . = ALIGN(4);
        /* init data */
        PROVIDE_HIDDEN (__init_array_start = .);
        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))
        PROVIDE_HIDDEN (__init_array_end = .);

        . = ALIGN(4);
        /* finit data */
        PROVIDE_HIDDEN (__fini_array_start = .);
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))
        PROVIDE_HIDDEN (__fini_array_end = .);

        KEEP(*(.jcr*))
        . = ALIGN(4);
        /* All data end */
        __ram_data_end__ = .;
    } > RAM AT > ROM

    .ram_bss :
    {
        . = ALIGN(4);
        __ram_bss_start__ = .;
        *(.bss)
        *(.bss.*)
        *(COMMON)
        . = ALIGN(4);
        __ram_bss_end__ = .;
    } > RAM

    .heap (NOLOAD) :
    {
        . = ALIGN(8);
        __end__ = .;
        PROVIDE(end = .);
        . = . + __HEAP_SIZE;
        . = ALIGN(8);
        __HeapLimit = .;
    } > RAM

    .stack (NOLOAD) :
    {
        . = ALIGN(8);
        __StackLimit = .;
        . = . + __STACK_SIZE - 0x8;
        . = ALIGN(8);
        __StackTop = .;
    } > RAM

    PROVIDE(__stack = __StackTop);

    /* check */
    ASSERT((ORIGIN(RAM) >= 0x20000000), "Error: RAM memory length should start from 0x20000000")
    ASSERT(((ORIGIN(RAM) + LENGTH(RAM)) <= (0x20000000 + 256K)), "Error: RAM memory should less than 0x20000000+256K")
    ASSERT((ORIGIN(ROM) >= 0x200000), "Error: ROM(RORAM) memory length should start from 0x200000")
    ASSERT(((ORIGIN(ROM) + LENGTH(ROM)) <= (0x200000 + 256K)), "Error: ROM(RORAM) memory should less than 0x200000+256K")
    ASSERT(((ORIGIN(ROM) - 0x200000) <= (ORIGIN(RAM) - 0x20000000)), "Error: ROM(RAM) should put before RWRAM")
}

/** @} */
